---
outline: deep
---

# Производительность {#performance}

## Обзор {#overview}

Vue спроектирован таким образом, чтобы обеспечить производительность для большинства распространенных сценариев использования без необходимости ручной оптимизации. Однако всегда есть сложные сценарии, в которых требуется дополнительная тонкая настройка. В этом разделе мы обсудим, на что следует обратить внимание, когда речь идет о производительности приложения Vue.

Прежде всего, давайте обсудим два основных аспекта веб-производительности:

- **Производительность загрузки страницы**: насколько быстро приложение отображает содержимое и становится интерактивным при первом посещении. Обычно этот показатель измеряется с помощью таких жизненно важных метрик, как [Largest Contentful Paint (LCP)](https://web.dev/lcp/) и [First Input Delay (FID)](https://web.dev/fid/).

- **Производительность обновления**: скорость обновления приложения в ответ на ввод пользователя. Например, как быстро обновляется список, когда пользователь набирает текст в поисковой строке, или как быстро переключается страница, когда пользователь нажимает навигационную ссылку в одностраничном приложении (SPA).

Идеально было бы максимизировать оба показателя, однако различные архитектуры фронтендов влияют на то, насколько легко достичь желаемой производительности в этих аспектах. Кроме того, тип создаваемого приложения в значительной степени влияет на то, чему следует отдать предпочтение в плане производительности. Поэтому первым шагом к обеспечению оптимальной производительности является выбор архитектуры, соответствующей типу создаваемого приложения:

- Обратитесь к разделу [Способы использования Vue](/guide/extras/ways-of-using-vue.html), чтобы узнать, как можно использовать Vue различными способами.

- Джейсон Миллер обсуждает типы веб-приложений и их идеальную реализацию/доставку в статье [Application Holotypes](https://jasonformat.com/application-holotypes/).

## Варианты профилирования {#profiling-options}

Чтобы повысить эффективность работы, необходимо знать, как ее измерить. Существует ряд замечательных инструментов, которые могут помочь в этом:

Для профилирования нагрузочной производительности производственных развертываний:

- [PageSpeed Insights](https://pagespeed.web.dev/)
- [WebPageTest](https://www.webpagetest.org/)

Для профилирования производительности при локальной разработке:

- [Chrome DevTools Performance Panel](https://developer.chrome.com/docs/devtools/evaluate-performance/)
  - [`app.config.performance`](/api/application.html#app-config-performance) включает маркеры производительности, специфичные для Vue, на временной шкале производительности Chrome DevTools.
- [Расширение Vue DevTools](/guide/scaling-up/tooling.html#browser-devtools) также предоставляет возможность профилирования производительности.

## Оптимизация загрузки страниц {#page-load-optimizations}

Существует множество аспектов оптимизации производительности загрузки страниц, не зависящих от фреймворка, - ознакомьтесь [с этим руководством web.dev](https://web.dev/fast/), чтобы получить исчерпывающую информацию. Здесь же мы сосредоточимся на методах, характерных для Vue.

### Выбор правильной архитектуры {#choosing-the-right-architecture}

Если ваш сценарий использования чувствителен к производительности загрузки страницы, избегайте использования его в качестве чисто клиентского SPA. Вы хотите, чтобы ваш сервер напрямую передавал HTML-содержимое, которое хотят увидеть пользователи. Чистый рендеринг на стороне клиента страдает от медленного времени перехода к содержимому. Эту проблему можно решить с помощью [рендеринга на стороне сервера (SSR)](/guide/extras/ways-of-using-vue.html#fullstack-ssr) или [генерацией статических сайтов (SSG)](/guide/extras/ways-of-using-vue.html#jamstack-ssg). Ознакомьтесь с [руководством по SSR](/guide/scaling-up/ssr.html) чтобы узнать, как выполнять SSR с помощью Vue. Если ваше приложение не требует высокой интерактивности, вы можете использовать традиционный внутренний сервер для рендеринга HTML и улучшения его с помощью Vue на клиенте.

Если ваше основное приложение должно быть SPA, но в нем есть маркетинговые страницы (лэндинг, о нас, блог), отправляйте их отдельно! В идеале маркетинговые страницы должны быть развернуты как статический HTML с минимальным количеством JS с помощью SSG.

### Размер пакета и tree-shaking {#bundle-size-and-tree-shaking}

Одним из наиболее эффективных способов повышения производительности загрузки страницы является доставка более компактных пакетов JavaScript. Вот несколько способов уменьшить размер пакета при использовании Vue:

- По возможности используйте шаг сборки.

  - Многие API-интерфейсы Vue ["tree-shakable"](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking), если они собраны с помощью современного инструмента сборки. Например, если вы не используете встроенный компонент `<Transition>`, он не будет включен в конечный пакет. В результате tree-shaking сборки могут быть удалены и другие неиспользуемые модули в исходном коде.

  - При использовании шага сборки шаблоны предварительно компилируются, поэтому нам не нужно поставлять компилятор Vue в браузер. Это позволяет сэкономить **14 кб** min+gzipped JavaScript и избежать затрат на компиляцию во время выполнения.

- Будьте внимательны к размеру при внедрении новых зависимостей! В реальных приложениях раздутые пакеты чаще всего являются результатом внедрения тяжелых зависимостей без осознания этого.

  - При использовании шага сборки отдавайте предпочтение зависимостям, предлагающим форматы модулей ES и дружественным к tree-shaking. Например, предпочтите `lodash-es`, а не `lodash`.

  - Проверьте размер зависимости и оцените, стоит ли она той функциональности, которую предоставляет. Обратите внимание, что если зависимость дружественна к tree-shaking, то фактическое увеличение размера будет зависеть от того, какие API вы импортируете из нее. Для быстрой проверки можно использовать такие инструменты, как [bundlejs.com](https://bundlejs.com/), но наиболее точным всегда будет измерение с помощью реальной настройки сборки.

- Если вы используете Vue в основном для прогрессивного улучшения и предпочитаете обойтись без шага сборки, рассмотрите вариант использования [petite-vue](https://github.com/vuejs/petite-vue) (всего **6 кб**).

### Разбиение кода {#code-splitting}

Разбиение кода - это разбиение пакета приложения на несколько небольших фрагментов, которые затем могут загружаться по требованию или параллельно. При правильном разделении кода функции, необходимые при загрузке страницы, могут быть загружены сразу, а дополнительные фрагменты будут загружаться в ленивом режиме только по мере необходимости, что повышает производительность.

Такие бандлеры, как Rollup (на котором основан Vite) или webpack, могут автоматически создавать разделенные куски, распознавая синтаксис динамического импорта ESM:

```js
// lazy.js и его зависимости будут выделены в отдельный чанк
// и загружены только при вызове `loadLazy()`.
function loadLazy() {
  return import('./lazy.js')
}
```

Ленивую загрузку лучше всего использовать для функций, которые не требуются сразу после начальной загрузки страницы. В приложениях Vue это можно использовать в сочетании с функцией Vue [асинхронных компонентов](/guide/components/async.html) для создания разделенных кусков для деревьев компонентов:

```js
import { defineAsyncComponent } from 'vue'

// для Foo.vue и его зависимостей создается отдельный чанк.
// он извлекается только по запросу, когда асинхронный компонент
// отображается на странице.
const Foo = defineAsyncComponent(() => import('./Foo.vue'))
```

В приложениях, использующих Vue Router, настоятельно рекомендуется использовать ленивую загрузку для компонентов маршрута. Vue Router имеет явную поддержку ленивой загрузки, отдельную от `defineAsyncComponent`. Более подробная информация приведена в разделе [ленивая загрузка маршрутов](https://router.vuejs.org/guide/advanced/lazy-loading.html).

## Оптимизация обновлений {#update-optimizations}

### Стабильность входных параметров {#props-stability}

В Vue дочерний компонент обновляется только тогда, когда изменяется хотя бы одно из полученных им свойств. Рассмотрим следующий пример:

```vue-html
<ListItem
  v-for="item in list"
  :id="item.id"
  :active-id="activeId" />
```

Внутри компонента `<ListItem>` он использует входный параметры `id` и `activeId`, чтобы определить, является ли он текущим активным элементом. Хотя это работает, проблема заключается в том, что всякий раз, когда изменяется `activeId`, **каждый** `<ListItem>` в списке должен обновляться!

В идеале, обновляться должны только те элементы, активный статус которых изменился. Этого можно добиться, если перенести вычисление активного состояния в родительский элемент, а вместо этого заставить `<ListItem>` непосредственно принимать `активный` входной параметр:

```vue-html
<ListItem
  v-for="item in list"
  :id="item.id"
  :active="item.id === activeId" />
```

Теперь для большинства компонентов `активный` входной параметр будет оставаться неизменным при изменении `activeId`, поэтому обновлять его больше не нужно. В целом, идея состоит в том, чтобы сохранить входные параметры, передаваемые дочерним компонентам, как можно более стабильными.

### `v-once` {#v-once}

`v-once` это встроенная директива, которая может использоваться для вывода содержимого, зависящего от данных во время выполнения программы, но не требующего обновления. При этом все поддерево, в котором она используется, будет пропущено при всех последующих обновлениях. Более подробная информация приведена в [справочнике API](/api/built-in-directives.html#v-once).

### `v-memo` {#v-memo}

`v-memo` - это встроенная директива, которая может использоваться для условного пропуска обновления больших поддеревьев или списков `v-for`. Для получения более подробной информации обратитесь к [справочнику API](/api/built-in-directives.html#v-memo).

## Общетехнические оптимизации {#general-optimizations}

> Следующие советы влияют как на загрузку страницы, так и на производительность обновления.

### Виртуализация больших списков {#virtualize-large-lists}

Одной из наиболее распространенных проблем производительности во всех фронтенд-приложениях является рендеринг больших списков. Каким бы производительным ни был фреймворк, рендеринг списка с тысячами элементов **будет** медленным из-за огромного количества узлов DOM, которые необходимо обработать браузеру.

Однако нам не обязательно отображать все эти узлы заранее. В большинстве случаев размер экрана пользователя может отобразить лишь небольшое подмножество нашего большого списка. Мы можем значительно повысить производительность с помощью **виртуализации списка** - техники отображения в большом списке только тех элементов, которые находятся в данный момент в области просмотра или рядом с ней.

Реализовать виртуализацию списков не так просто, но, к счастью, существуют библиотеки сообщества, которые можно использовать напрямую:

- [vue-virtual-scroller](https://github.com/Akryum/vue-virtual-scroller)
- [vue-virtual-scroll-grid](https://github.com/rocwang/vue-virtual-scroll-grid)
- [vueuc/VVirtualList](https://github.com/07akioni/vueuc)

### Уменьшение накладных расходов на реактивность для больших неизменяемых структур {#reduce-reactivity-overhead-for-large-immutable-structures}

Система реактивности Vue по умолчанию является глубокой. Хотя это делает управление состоянием интуитивно понятным, при больших объемах данных это создает определенный уровень накладных расходов, поскольку при каждом обращении к свойствам запускаются прокси-ловушки, выполняющие отслеживание зависимостей. Обычно это становится заметным при работе с большими массивами глубоко вложенных объектов, когда при одном рендере необходимо получить доступ к 100 000+ свойствам, поэтому это должно влиять только на очень специфические случаи использования.

Vue предоставляет возможность отказаться от глубокой реактивности, используя функции [`shallowRef()`](/api/reactivity-advanced.html#shallowref) и [`shallowReactive()`](/api/reactivity-advanced.html#shallowreactive). Shallow API создают состояние, которое является реактивным только на корневом уровне, а все вложенные объекты остаются нетронутыми. Это обеспечивает быстрый доступ к вложенным свойствам, но в качестве компромисса мы должны рассматривать все вложенные объекты как неизменяемые, а обновления могут быть вызваны только заменой корневого состояния:

```js
const shallowArray = shallowRef([
  /* большой перечень глубоких объектов */
])

// это не приведет к обновлению...
shallowArray.value.push(newObject)
// это приведет:
shallowArray.value = [...shallowArray.value, newObject]

// это не приведет к обновлению...
shallowArray.value[0].foo = 1
// это приведет:
shallowArray.value = [
  {
    ...shallowArray.value[0],
    foo: 1
  },
  ...shallowArray.value.slice(1)
]
```

### Избегайте ненужных абстракций компонентов {#avoid-unnecessary-component-abstractions}

Иногда для улучшения абстракции или организации кода мы можем создавать [компоненты без рендеринга](/guide/components/slots.html#renderless-components) или компоненты более высокого порядка (т.е. компоненты, которые рендерят другие компоненты с дополнительными входными параметрами). Хотя в этом нет ничего плохого, следует помнить, что экземпляры компонентов гораздо дороже простых узлов DOM, и создание слишком большого их количества в результате использования шаблонов абстракции приведет к снижению производительности.

Заметим, что уменьшение количества экземпляров не даст заметного эффекта, поэтому не стоит беспокоиться, если компонент будет отображаться в приложении всего несколько раз. Лучший сценарий для рассмотрения этой оптимизации - опять же большие списки. Представьте себе список из 100 элементов, в котором каждый компонент элемента содержит множество дочерних компонентов. Удаление одной ненужной абстракции компонента здесь может привести к сокращению сотен экземпляров компонентов.
