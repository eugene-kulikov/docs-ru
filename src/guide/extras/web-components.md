# Vue и веб-компоненты {#vue-and-web-components}

[Веб-компоненты](https://developer.mozilla.org/en-US/docs/Web/Web_Components) - это общий термин для набора собственных веб-интерфейсов, позволяющих разработчикам создавать многократно используемые пользовательские элементы.

Мы считаем Vue и Web Components в первую очередь взаимодополняющими технологиями. Vue имеет отличную поддержку как для использования, так и для создания пользовательских элементов. Независимо от того, интегрируете ли вы пользовательские элементы в существующее приложение Vue или используете Vue для создания и распространения пользовательских элементов, вы находитесь в хорошей компании.

## Использование пользовательских элементов в Vue {#using-custom-elements-in-vue}

В тесте ["пользовательские элементы повсюду" Vue получил 100% баллов](https://custom-elements-everywhere.com/libraries/vue/results/results.html). Использование пользовательских элементов в приложении Vue в основном работает так же, как и использование собственных HTML-элементов, но есть несколько моментов, о которых следует помнить:

### Пропуск разрешения компонента {#skipping-component-resolution}

По умолчанию Vue будет пытаться разрешить неродной HTML-тег как зарегистрированный компонент Vue, прежде чем вернуться к его рендерингу как пользовательского элемента. Это приведет к тому, что во время разработки Vue выдаст предупреждение "не удалось разрешить компонент". Чтобы сообщить Vue, что определенные элементы должны рассматриваться как пользовательские и пропускать разрешение компонента, мы можем указать [параметр `compilerOptions.isCustomElement`](/api/application.html#app-config-compileroptions).

Если вы используете Vue с настройками сборки, то опция должна передаваться через конфигурацию сборки, поскольку это опция времени компиляции.

#### Пример настройки в браузере {#example-in-browser-config}

```js
// Работает только при использовании компиляции в браузере.
// При использовании средств сборки см. примеры конфигурации ниже.
app.config.compilerOptions.isCustomElement = (tag) => tag.includes('-')
```

#### Пример настройки Vite {#example-vite-config}

```js
// vite.config.js
import vue from '@vitejs/plugin-vue'

export default {
  plugins: [
    vue({
      template: {
        compilerOptions: {
          // рассматривать все теги с тире как пользовательские элементы
          isCustomElement: (tag) => tag.includes('-')
        }
      }
    })
  ]
}
```

#### Пример настройки Vue CLI {#example-vue-cli-config}

```js
// vue.config.js
module.exports = {
  chainWebpack: config => {
    config.module
      .rule('vue')
      .use('vue-loader')
      .tap(options => ({
        ...options,
        compilerOptions: {
          // Все теги, начинающиеся с ion-, рассматриваются как пользовательские элементы
          isCustomElement: tag => tag.startsWith('ion-')
        }
      }))
  }
}
```

### Передача свойств DOM {#passing-dom-properties}

Поскольку атрибуты DOM могут быть только строками, нам необходимо передавать сложные данные в пользовательские элементы в виде свойств DOM. При установке входных параметров для пользовательского элемента Vue 3 автоматически проверяет наличие DOM-свойства с помощью оператора `in` и предпочитает устанавливать значение как DOM-свойство, если ключ присутствует. Это означает, что в большинстве случаев вам не придется задумываться об этом, если пользовательский элемент соответствует [рекомендуемым лучшим практикам](https://web.dev/custom-elements-best-practices/).

Однако возможны редкие случаи, когда данные должны передаваться как свойство DOM, но пользовательский элемент не определяет/отражает свойство должным образом (что приводит к неудаче проверки `in`). В этом случае можно заставить `v-bind` привязку быть установленной как свойство DOM с помощью модификатора `.prop`:

```vue-html
<my-element :user.prop="{ name: 'Джек' }"></my-element>

<!-- shorthand equivalent -->
<my-element .user="{ name: 'Джек' }"></my-element>
```

## Создание пользовательских элементов с помощью Vue {#building-custom-elements-with-vue}

Основное преимущество пользовательских элементов заключается в том, что они могут использоваться с любым фреймворком или даже без него. Это делает их идеальными для распространения компонентов, когда конечный потребитель может использовать не тот же стек фронтендов, или когда необходимо изолировать конечное приложение от деталей реализации используемых компонентов.

### defineCustomElement {#definecustomelement}

Vue поддерживает создание пользовательских элементов с использованием точно таких же API компонентов Vue с помощью метода [`defineCustomElement`](/api/general.html#definecustomelement). Метод принимает тот же аргумент, что и [`defineComponent`](/api/general.html#definecomponent), но вместо него возвращает конструктор пользовательского элемента, который расширяет `HTMLElement`:

```vue-html
<my-vue-element></my-vue-element>
```

```js
import { defineCustomElement } from 'vue'

const MyVueElement = defineCustomElement({
  // обычные параметры компонента Vue здесь
  props: {},
  emits: {},
  template: `...`,

  // только defineCustomElement: CSS для внедрения в корень тени
  styles: [`/* встраиваемый css */`]
})

// Регистрируем пользовательский элемент.
// После регистрации все теги `<my-vue-element>`
// на странице будут обновлены.
customElements.define('my-vue-element', MyVueElement)

// Можно также программно инициировать элемент:
// (может быть выполнено только после регистрации)
document.body.appendChild(
  new MyVueElement({
    // начальные реквизиты (необязательно)
  })
)
```

#### Жизненный цикл {#lifecycle}

- Пользовательский элемент Vue будет монтировать внутренний экземпляр компонента Vue внутри своего корня тени при первом вызове функции [`connectedCallback`](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks) элемента.

- Когда вызывается `disconnectedCallback` элемента, Vue проверяет, отсоединен ли элемент от документа после тика микрозадачи.

  - Если элемент все еще находится в документе, то это перемещение, и экземпляр компонента будет сохранен;

  - Если элемент отсоединен от документа, то это является удалением, и экземпляр компонента будет размонтирован.

#### Входные параметры {#props}

- Все входные параметры, объявленные с помощью опции `props`, будут определены в пользовательском элементе как свойства. Vue будет автоматически обрабатывать отражение между атрибутами/свойствами, где это необходимо.

  - Атрибуты всегда отражаются на соответствующих свойствах.

  - Свойства с примитивными значениями (`string`, `boolean` или `number`) отражаются как атрибуты.

- Vue также автоматически приводит входные параметры, объявленные с типами `Boolean` или `Number`, к нужному типу, когда они задаются в качестве атрибутов (которые всегда являются строками). Например, при следующем объявлении входного параметра:

  ```js
  props: {
    selected: Boolean,
    index: Number
  }
  ```

  И использование пользовательского элемента:

  ```vue-html
  <my-element selected index="1"></my-element>
  ```

  В компоненте `selected` будет приведен к `true` (boolean) и `index` будет приведен к `1` (number).

#### События {#events}

События, переданные через `this.$emit` или setup `emit` отправляются как собственные [CustomEvents](https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events#adding_custom_data_%E2%80%93_customevent) на пользовательском элементе. Дополнительные аргументы события ("payload") будут выведены в виде массива на объект CustomEvent в качестве его свойства `detail`.

#### Слоты {#slots}

Внутри компонента слоты могут быть отображены с помощью элемента `<slot/>` как обычно. Однако при обработке результирующего элемента он принимает только [собственный синтаксис слотов](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots):

- [Слоты с ограниченной областью видимости](/guide/components/slots.html#scoped-slots) не поддерживаются.

- При передаче именованных слотов вместо директивы `v-slot` следует использовать атрибут `slot`:

  ```vue-html
  <my-element>
    <div slot="named">привет</div>
  </my-element>
  ```

#### Provide / Inject {#provide-inject}

[API Provide / Inject](/guide/components/provide-inject.html#provide-inject) и его [эквивалент Composition API](/api/composition-api-dependency-injection.html#provide) также работают между пользовательскими элементами, определяемыми Vue. Однако обратите внимание, что это работает **только между пользовательскими элементами**, т.е. пользовательский элемент, определяемый Vue, не сможет внедрить свойства, предоставленные компонентом Vue, не являющимся пользовательским элементом.

### SFC как собственный элемент {#sfc-as-custom-element}

`defineCustomElement` также работает с однофайловыми компонентами Vue (SFC). Однако при стандартной настройке инструментария `<style>` внутри SFC все равно будут извлечены и объединены в один CSS-файл при сборке. При использовании SFC в качестве пользовательского элемента часто желательно внедрять теги `<style>` в теневой корень пользовательского элемента.

Официальные инструменты SFC поддерживают импорт SFC в "режиме пользовательского компонента" (требуется `@vitejs/plugin-vue@^1.4.0` или `vue-loader@^16.5.0`). SFC, загруженный в режиме пользовательского элемента, вставляет свои теги `<style>` в виде строк CSS и раскрывает их в параметре `styles`. Они будут обработаны `defineCustomElement` и внедрены в теневой корень элемента при его инициализации.

Чтобы перейти в этот режим, достаточно в конце имени файла компонента указать `.ce.vue`:

```js
import { defineCustomElement } from 'vue'
import Example from './Example.ce.vue'

console.log(Example.styles) // ["/* inlined css */"]

// преобразование в конструктор пользовательского элемента
const ExampleElement = defineCustomElement(Example)

// регистрация
customElements.define('my-example', ExampleElement)
```

Если вы хотите настроить, какие файлы должны импортироваться в режиме пользовательских элементов (например, рассматривать все SFC как пользовательские элементы), вы можете передать параметр `customElement` соответствующим плагинам сборки:

- [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#using-vue-sfcs-as-custom-elements)
- [vue-loader](https://github.com/vuejs/vue-loader/tree/next#v16-only-options)

### Советы по созданию библиотеки пользовательских элементов Vue {#tips-for-a-vue-custom-elements-library}

При создании пользовательских элементов с помощью Vue элементы будут опираться на время выполнения Vue. В зависимости от того, сколько функций используется, базовый размер будет составлять ~16 Кб. Это означает, что использование Vue не является идеальным, если вы поставляете один пользовательский элемент - возможно, вам стоит использовать ванильный JavaScript, [petite-vue](https://github.com/vuejs/petite-vue), или фреймворки, специализирующиеся на небольших размерах времени выполнения. Однако базовый размер более чем оправдан, если вы поставляете набор пользовательских элементов со сложной логикой, поскольку Vue позволяет создавать каждый компонент с гораздо меньшим количеством кода. Чем больше элементов вы поставляете вместе, тем лучше соотношение.

Если пользовательские элементы будут использоваться в приложении, в котором также используется Vue, можно выбрать внешнее внедрение Vue из собранного пакета, чтобы элементы использовали ту же копию Vue, что и в хост-приложении.

Рекомендуется экспортировать отдельные конструкторы элементов, чтобы дать пользователям возможность импортировать их по требованию и регистрировать их с нужными именами тегов. Можно также экспортировать удобную функцию для автоматической регистрации всех элементов. Вот пример точки входа пользовательской библиотеки элементов Vue:

```js
import { defineCustomElement } from 'vue'
import Foo from './MyFoo.ce.vue'
import Bar from './MyBar.ce.vue'

const MyFoo = defineCustomElement(Foo)
const MyBar = defineCustomElement(Bar)

// экспорт отдельных элементов
export { MyFoo, MyBar }

export function register() {
  customElements.define('my-foo', MyFoo)
  customElements.define('my-bar', MyBar)
}
```

Если у вас много компонентов, вы также можете использовать такие возможности инструментов сборки, как [glob import](https://vitejs.dev/guide/features.html#glob-import) или [`require.context`](https://webpack.js.org/guides/dependency-management/#requirecontext) в webpack, чтобы загрузить все компоненты из каталога.

## Веб-компоненты в сравнении с компонентами Vue {#web-components-vs-vue-components}

Некоторые разработчики считают, что следует избегать использования проприетарных компонентных моделей фреймворка и что только использование пользовательских элементов делает приложение "перспективным". Здесь мы попытаемся объяснить, почему мы считаем, что это слишком упрощенный взгляд на проблему.

Между Custom Elements и Vue Components действительно есть определенное совпадение функций: они позволяют определять многократно используемые компоненты с передачей данных, эмуляцией событий и управлением жизненным циклом. Однако API веб-компонентов относительно низкоуровневые и "голые". Для создания реального приложения нам потребуется достаточно много дополнительных возможностей, которые платформа не предоставляет:

- Декларативная и эффективная система шаблонов;

- Реактивная система управления состоянием, облегчающая извлечение и повторное использование межкомпонентной логики;

- Эффективный способ рендеринга компонентов на сервере и их гидрации на клиенте (SSR), что важно для SEO и [таких метрик Web Vitals, как LCP](https://web.dev/vitals/). SSR нативных пользовательских элементов обычно включает в себя имитацию DOM в Node.js и последующую сериализацию мутированного DOM, в то время как Vue SSR компилируется в конкатенацию строк, когда это возможно, что гораздо эффективнее.

Компонентная модель Vue разработана с учетом этих потребностей как целостная система.

При наличии компетентной команды инженеров вы, вероятно, могли бы построить эквивалент поверх собственных Custom Elements - но это означает, что вы берете на себя долгосрочное бремя поддержки собственного фреймворка, теряя при этом преимущества экосистемы и сообщества, присущие такому зрелому фреймворку, как Vue.

Существуют также фреймворки, построенные с использованием Custom Elements в качестве основы компонентной модели, но все они неизбежно вынуждены внедрять свои собственные решения перечисленных выше проблем. Использование таких фреймворков подразумевает принятие технических решений по решению этих проблем, что, несмотря на заявления рекламодателей, автоматически не защищает вас от возможных изменений в будущем.

Есть также некоторые области, в которых пользовательские элементы, на наш взгляд, являются ограничивающими:

- Ускоренная обработка слотов мешает компоновке компонентов. [Слоты с ограниченной областью видимости](/guide/components/slots.html#scoped-slots) Vue являются мощным механизмом компоновки компонентов, который не может быть реализован в пользовательских элементах из-за особенностей собственных слотов. Кроме того, ускоренная обработка слотов означает, что полученный компонент не может контролировать, будет ли отрисован тот или иной фрагмент содержимого слота.

- Сегодня доставка пользовательских элементов с теневым DOM scoped CSS требует встраивания CSS в JavaScript, чтобы они могли быть внедрены в теневые корни во время выполнения. Кроме того, в сценариях SSR они приводят к дублированию стилей в разметке. В этой области ведется работа над [платформенными функциями](https://github.com/whatwg/html/pull/4898/), но на данный момент они еще не поддерживаются повсеместно, а также остаются проблемы с производительностью и SSR. Тем временем Vue SFC предоставляют [муханизмы CSS scoping](/api/sfc-css-features.html), которые поддерживают извлечение стилей в обычные CSS-файлы.

Vue всегда будет оставаться в курсе последних стандартов веб-платформы, и мы с удовольствием будем использовать все, что предоставляет платформа, если это облегчит нашу работу. Однако наша цель - предоставлять решения, которые хорошо работают и работают сегодня. Это означает, что к внедрению новых возможностей платформы мы должны подходить с критическим настроем - и это предполагает заполнение пробелов там, где стандарты не соответствуют требованиям, пока это еще возможно.
