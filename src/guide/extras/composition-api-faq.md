---
outline: deep
---

# FAQ по Composition API {#composition-api-faq}

:::tip Совет
Данный FAQ предполагает наличие опыта работы с Vue - в частности, опыта работы с Vue 2 при преимущественном использовании API Options.
:::

## Что такое Composition API? {#what-is-composition-api}

Composition API - это набор API, который позволяет нам создавать компоненты Vue, используя импортированные функции вместо объявления опций. Это общий термин, который охватывает следующие API:

- [Reactivity API](/api/reactivity-core.html), например `ref()` и `reactive()`,  которые позволяют напрямую создавать реактивное состояние, вычисляемое состояние и наблюдатели.

- [Хуки жизненого цикла](/api/composition-api-lifecycle.html), например `onMounted()` и `onUnmounted()`, позволяющие программно подключаться к жизненному циклу компонента.

- [Dependency Injection](/api/composition-api-dependency-injection.html), т.е. `provide()` и `inject()`, позволяющие использовать систему инъекции зависимостей Vue при использовании Reactivity API.

Composition API является встроенной функцией Vue 3 и [Vue 2.7](https://blog.vuejs.org/posts/vue-2-7-naruto.html). Для старых версий Vue 2 используйте официально поддерживаемый плагин [`@vue/composition-api`](https://github.com/vuejs/composition-api). В Vue 3 он также в основном используется вместе с синтаксисом [`<script setup>`](/api/sfc-script-setup.html) в однофайловых компонентах. Вот базовый пример компонента, использующего Composition API:

```vue
<script setup>
import { ref, onMounted } from 'vue'

// реактивное состояние
const count = ref(0)

// функции, изменяющие состояние и запускающие обновления
function increment() {
  count.value++
}

// хуки жизненного цикла
onMounted(() => {
  console.log(`Начальный подсчет равен ${count.value}.`)
})
</script>

<template>
  <button @click="increment">Подсчет равен: {{ count }}</button>
</template>
```

Несмотря на стиль API, основанный на композиции функций, **Composition API НЕ является функциональным программированием**. Composition API базируется на парадигме Vue, основанной на мутабельной и гибкой реактивности, в то время как функциональное программирование делает акцент на неизменяемости.

Если вы хотите узнать, как использовать Vue с Composition API, вы можете установить предпочтение Composition API для всего сайта с помощью переключателя в верхней части левой боковой панели, а затем пройти это руководство с самого начала.

## Зачем нужен Composition API? {#why-composition-api}

### Улучшение повторного использования логики {#better-logic-reuse}

Основное преимущество Composition API заключается в том, что он обеспечивает чистое и эффективное повторное использование логики в виде [Composable функций](/guide/reusability/composables.html). Это решает [все недостатки миксинов](/guide/reusability/composables.html#vs-mixins), основного механизма повторного использования логики в Options API.

Возможности Composition API по повторному использованию логики привели к появлению таких впечатляющих проектов сообщества, как [VueUse](https://vueuse.org/) - постоянно растущей коллекции composable утилит. Он также служит чистым механизмом для простой интеграции в систему реактивности Vue сторонних сервисов и библиотек с изменяемым состоянием, например, [неизменяемых данных](/guide/extras/reactivity-in-depth.html#immutable-data), [конечных автоматов](/guide/extras/reactivity-in-depth.html#state-machines), и [RxJS](https://vueuse.org/rxjs/readme.html#vueuse-rxjs).

### Более гибкая организация кода {#more-flexible-code-organization}

Многим пользователям нравится, что с помощью Options API мы по умолчанию пишем упорядоченный код: все находится на своем месте в зависимости от того, к какой опции оно относится. Однако Options API накладывает серьезные ограничения, когда логика одного компонента перерастает определенный порог сложности. Особенно ярко это ограничение проявляется в компонентах, где необходимо решать несколько **логических задач**, что мы не раз наблюдали во многих готовых приложениях на Vue 2.

Возьмем для примера компонент folder explorer из графического интерфейса Vue CLI: этот компонент отвечает за следующие логические задачи:

- Отслеживание текущего состояния папки и отображение ее содержимого
- Обработка навигации по папкам (открытие, закрытие, обновление...)
- Обработка создания новой папки
- Переключение показа только избранных папок
- Переключение показа скрытых папок
- Обработка изменений текущего рабочего каталога

[Первоначальная версия](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404) компонента была написана на Options API. Если присвоить каждой строке кода цвет в зависимости от того, с какой логической проблемой она имеет дело, то это будет выглядеть следующим образом:

<img alt="компонент папки до" src="./images/options-api.png" width="129" height="500" style="margin: 1.2em auto">

Обратите внимание, что код, связанный с одной и той же логической проблемой, приходится разбивать на разные опции, расположенные в разных частях файла. В компоненте длиной в несколько сотен строк понимание и навигация по одной логической проблеме требует постоянного прокручивания файла вверх и вниз, что значительно усложняет задачу. Кроме того, если мы собираемся извлечь логический компонент в утилиту многократного использования, то поиск и извлечение нужных фрагментов кода из разных частей файла потребует значительных усилий.

Вот один и тот же компонент до и после [рефакторинга в Composition API](https://gist.github.com/yyx990803/8854f8f6a97631576c14b63c8acd8f2e):

![компонент папки после](./images/composition-api-after.png)

Обратите внимание, что код, относящийся к одной и той же логической проблеме, теперь можно сгруппировать вместе: нам больше не нужно перескакивать между различными блоками опций при работе над конкретной логической проблемой. Более того, теперь мы можем перенести группу кода во внешний файл с минимальными усилиями, поскольку нам больше не нужно перемешивать код, чтобы извлечь его. Такое снижение трудоемкости рефакторинга является залогом долговременной сопровождаемости больших кодовых баз.

### Улучшенный вывод типов {#better-type-inference}

В последние годы все больше фронтенд-разработчиков переходят на [TypeScript](https://www.typescriptlang.org/), поскольку он помогает нам писать более надежный код, вносить изменения с большей уверенностью и обеспечивает отличные возможности разработки с поддержкой IDE. Однако API Options, изначально задуманный в 2013 году, был разработан без учета вывода типов. Чтобы сделать вывод типов в API Options, нам пришлось прибегнуть к [абсурдно сложной манипуляции с типами](https://github.com/vuejs/core/blob/44b95276f5c086e1d88fa3c686a5f39eb5bb7821/packages/runtime-core/src/componentPublicInstance.ts#L132-L165). Даже несмотря на все эти усилия, вывод типов для Options API все равно может быть нарушен для миксинов и внедрения зависимостей.

Это привело к тому, что многие разработчики, желающие использовать Vue с TS, склонялись к классовому API на базе `vue-class-component`. Однако API на основе классов в значительной степени зависит от декораторов ES - языковой функции, которая на момент разработки Vue 3 в 2019 году находилась лишь на 2-ой стадии. Мы посчитали, что слишком рискованно основывать официальный API на нестабильном решении. С тех пор предложение по декораторам прошло еще одну полную переработку и в 2022 году достигло стадии 3. Кроме того, API на основе классов страдает от ограничений повторного использования логики и организации, аналогичных Options API.

В отличие от этого, в Composition API используются в основном простые переменные и функции, которые, естественно, дружественны к типам. Код, написанный на Composition API, может пользоваться полным выводом типов без необходимости ручного указания типов. В большинстве случаев код Composition API будет выглядеть практически одинаково на TypeScript и обычном JavaScript. Это также позволяет пользователям обычного JavaScript использовать частичный вывод типов.

### Меньший размер пакета и меньшие затраты {#smaller-production-bundle-and-less-overhead}

Код, написанный в Composition API и `<script setup>`, также более эффективен и удобен для минификации, чем эквивалент Options API. Это связано с тем, что шаблон в компоненте `<script setup>` компилируется как функция, встроенная в ту же область видимости, что и код `<script setup>`.  В отличие от доступа к свойствам из `this`, скомпилированный код шаблона может напрямую обращаться к переменным, объявленным внутри `<script setup>`, без прокси экземпляра между ними. Это также приводит к улучшению минификации, поскольку все имена переменных могут быть безопасно сокращены.

## Взаимосвязь с Options API {#relationship-with-options-api}

### Компромиссные решения {#trade-offs}

Некоторые пользователи, перешедшие с Options API, обнаружили, что код Composition API менее организован, и пришли к выводу, что Composition API "хуже" с точки зрения организации кода. Мы рекомендуем пользователям, имеющим такое мнение, посмотреть на эту проблему с другой стороны.

Действительно, Composition API больше не предоставляет "ограждений", которые указывают, как разместить код в соответствующих блоках. Взамен вы получаете возможность писать компонентный код так же, как вы писали бы обычный JavaScript. Это означает, **что к коду Composition API можно и нужно применять любые лучшие практики организации кода, как и при написании обычного JavaScript**. Если вы умеете писать хорошо организованный JavaScript, то должны уметь писать и хорошо организованный код Composition API.

Options API действительно позволяет "меньше думать" при написании компонентного кода, за что его и любят многие пользователи. Однако, снижая умственные затраты, он также закрепляет за вами предписанный шаблон организации кода, не давая возможности выхода, что может затруднить рефакторинг или повышение качества кода в крупных проектах. В этом отношении API Composition обеспечивает лучшую долгосрочную масштабируемость.

### Охватывает ли Composition API все варианты использования? {#does-composition-api-cover-all-use-cases}

Да, с точки зрения логики с состоянием. При использовании Composition API может потребоваться всего несколько опций: `props`, `emits`, `name`, и `inheritAttrs`. Если используется `<script setup>`, то `inheritAttrs` - это, как правило, единственная опция, для которой может потребоваться отдельный обычный блок `<script>`.

Если вы планируете использовать только Composition API (наряду с перечисленными выше опциями), вы можете сэкономить несколько килобайт от вашего пакета для продакшена с помощью [compile-time flag](https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags), который удаляет код, связанный с Options API, из Vue. Обратите внимание, что это также влияет на компоненты Vue в ваших зависимостях.

### Могу ли я использовать оба API вместе? {#can-i-use-both-apis-together}

Да. Вы можете использовать Composition API через опцию [`setup()`](/api/composition-api-setup.html) в компоненте Options API.

Однако мы рекомендуем делать это только в том случае, если у вас есть существующая кодовая база Options API, которую необходимо интегрировать с новыми возможностями / внешними библиотеками, написанными с использованием Composition API.

### Будет ли API Options устаревшим? {#will-options-api-be-deprecated}

Нет, мы не планируем этого делать. Options API является неотъемлемой частью Vue и причиной любви к нему многих разработчиков. Мы также понимаем, что многие преимущества Composition API проявляются только в крупных проектах, и Options API остается надежным выбором для многих сценариев низкой и средней сложности.

## Взаимосвязь с Class API {#relationship-with-class-api}

Мы больше не рекомендуем использовать Class API в Vue 3, поскольку Composition API обеспечивает отличную интеграцию с TypeScript и дополнительные преимущества повторного использования логики и организации кода.

## Сравнение с React Hooks {#comparison-with-react-hooks}

Composition API обеспечивает тот же уровень возможностей логической композиции, что и React Hooks, но с некоторыми важными отличиями.

React Hooks вызываются многократно при каждом обновлении компонента. Это создает ряд неудобств, которые могут запутать даже опытных разработчиков React. Кроме того, это приводит к проблемам оптимизации производительности, которые могут сильно повлиять на удобство разработки. Вот несколько примеров:

- Хуки чувствительны к порядку вызова и не могут быть условными.

- Переменные, объявленные в компоненте React, могут быть захвачены закрытием хука и стать "неактуальными", если разработчик не передаст корректный массив зависимостей. Это приводит к тому, что разработчики React полагаются на правила ESLint для обеспечения корректной передачи зависимостей. Однако эти правила часто оказываются недостаточно продуманными и чрезмерно компенсируют корректность, что приводит к ненужной валидации и головной боли при возникновении нестандартных ситуаций.

- Затратные вычисления требуют использования функции `useMemo`, которая опять же требует ручной передачи корректного массива зависимостей.

- Обработчики событий, передаваемые дочерним компонентам, по умолчанию вызывают ненужные обновления дочерних компонентов и требуют явного `useCallback` в качестве оптимизации. Это почти всегда необходимо, и опять же требует корректного массива зависимостей. Пренебрежение этим фактом приводит к тому, что приложения по умолчанию перерисовываются, что может привести к проблемам с производительностью, даже не осознавая этого.

- Проблема устаревших замыканий в сочетании с функциями Concurrent затрудняет понимание того, когда выполняется тот или иной фрагмент кода хука, и делает работу с изменяемым состоянием, которое должно сохраняться во время рендеринга (через `useRef`), громоздкой.

Для сравнения, Vue Composition API:

- Вызывает код `setup()` или `<script setup>` только один раз. Это позволяет лучше согласовать код с интуицией идиоматического использования JavaScript, поскольку нет необходимости беспокоиться об устаревших закрытиях. Вызовы Composition API также не чувствительны к порядку вызовов и могут быть условными.

- Система реактивности Vue во время выполнения автоматически собирает реактивные зависимости, используемые в вычисляемых свойствах и наблюдателях, поэтому нет необходимости вручную объявлять зависимости.

- Нет необходимости вручную кэшировать функции обратного вызова, чтобы избежать ненужных обновлений дочерних компонентов. В целом, благодаря детальной системе реактивности Vue дочерние компоненты обновляются только тогда, когда это необходимо. Оптимизация ручного обновления дочерних компонентов редко волнует разработчиков Vue.

Мы признаем творческий потенциал React Hooks, и он является основным источником вдохновения для Composition API. Однако упомянутые выше проблемы в его дизайне все же существуют, и мы заметили, что модель реактивности Vue предоставляет возможность их обойти.
